/*!
 * Copyright (c) 2019 Contributors to the Eclipse Foundation
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0
 *
 * SPDX-License-Identifier: EPL-2.0
 */
import { DittoProtocolEnvelope, DittoProtocolResponse } from '../../../model/ditto-protocol';
/**
 * An abstract factory that builds ResilienceHandlers.
 */
export declare abstract class ResilienceHandlerFactory implements ResilienceHandlerFactoryBuildStep, ResilienceHandlerFactoryContextStep {
    protected webSocketBuilder: WebSocketImplementationBuilderHandler;
    protected stateHandler: WebSocketStateHandler;
    withContext(webSocketBuilder: WebSocketImplementationBuilderHandler, stateHandler: WebSocketStateHandler): ResilienceHandlerFactoryBuildStep;
    abstract withRequestHandler(requestHandler: RequestHandler): ResilienceHandler;
}
export interface ResilienceHandlerFactoryBuildStep {
    /**
     * Builds a ResilienceHandler using the specified RequestHandler.
     *
     * @param requestHandler - The RequestHandler to use
     * @returns The ResilienceHandler
     */
    withRequestHandler(requestHandler: RequestHandler): ResilienceHandler;
}
export interface ResilienceHandlerFactoryContextStep {
    /**
     * Uses the web socket and state handler to build the ResilienceHandler.
     *
     * @param webSocketBuilder - The web socket to use.
     * @param stateHandler - The state handler to use.
     * @returns The ResilienceHandlerFactoryBuildStep
     */
    withContext(webSocketBuilder: WebSocketImplementationBuilderHandler, stateHandler: WebSocketStateHandler): ResilienceHandlerFactoryBuildStep;
}
export interface RequestHandler {
    /**
     * Analyzes a message from the web socket connection and passes it on to the correct handle.
     *
     * @param correlationId - The correlation-id of the message.
     * @param message - The message.
     */
    handleInput(correlationId: string, message: DittoProtocolResponse): void;
    /**
     * Matches an incoming message to the registered subscriptions and triggers them.
     *
     * @param message - The message.
     */
    handleMessage(message: DittoProtocolResponse): void;
    /**
     * Rejects and deletes a failed request.
     *
     * @param correlationId - The correlation-id of the request.
     * @param cause - The cause of the failure.
     */
    handleError(correlationId: string, cause: object): void;
}
export declare enum WebSocketBindingMessage {
    START_SEND_EVENTS = "START-SEND-EVENTS",
    STOP_SEND_EVENTS = "STOP-SEND-EVENTS",
    START_SEND_MESSAGES = "START-SEND-MESSAGES",
    STOP_SEND_MESSAGES = "STOP-SEND-MESSAGES",
    START_SEND_LIVE_COMMANDS = "START-SEND-LIVE-COMMANDS",
    STOP_SEND_LIVE_COMMANDS = "STOP-SEND-LIVE-COMMANDS",
    START_SEND_LIVE_EVENTS = "START-SEND-LIVE-EVENTS",
    STOP_SEND_LIVE_EVENTS = "STOP-SEND-LIVE-EVENTS"
}
export interface ResilienceHandler extends ResponseHandler {
    /**
     * Sends a request over the web socket connection.
     *
     * @param correlationId - The id of the request to send.
     * @param request - The request to send.
     */
    sendRequest(correlationId: string, request: DittoProtocolEnvelope): void;
    /**
     * Sends a websocket specific binding message.
     *
     * @param message - The message to send.
     * @returns A Promise that resolves once the request was acknowledged
     */
    sendProtocolMessage(message: WebSocketBindingMessage): Promise<void>;
    /**
     * Sends a message.
     *
     * @param message - The message to send.
     * @returns A Promise that resolves once the message was sent and rejects if the sending was unsuccessful
     */
    send(message: string): Promise<void>;
}
export declare abstract class AbstractResilienceHandler implements ResilienceHandler {
    protected readonly requestHandler: RequestHandler;
    private readonly protocolMessages;
    protected readonly stateHandler: ResilienceStateHandler;
    constructor(stateHandler: WebSocketStateHandler, requestHandler: RequestHandler);
    private static isWebSocketBindingMessage;
    handleInput(input: string): void;
    sendProtocolMessage(message: WebSocketBindingMessage): Promise<void>;
    private handleWebSocketBindingMessage;
    handleMessage(message: DittoProtocolResponse): void;
    handleClose(promise: Promise<WebSocketImplementation>): void;
    handleError(error: string): void;
    protected abstract rejectAllOngoing(reason: object): void;
    protected abstract resolveWebSocket(promise: Promise<WebSocketImplementation>): void;
    abstract handleFailure(correlationId: string, reason: any): void;
    abstract handleResponse(correlationId: string | undefined, response: DittoProtocolResponse): void;
    abstract send(message: string): Promise<void>;
    abstract sendRequest(correlationId: string, request: DittoProtocolEnvelope): void;
}
export interface WebSocketStateHandler {
    /**
     * Sets the connection state to 'connected' and if the state changed sends the according event.
     */
    connected(): void;
    /**
     * Sets the connection state to 'buffering' and if the state changed sends the according event.
     */
    buffering(): void;
    /**
     * Sets the connection state to 'buffering' and if the state changed sends the according event.
     */
    backPressure(): void;
    /**
     * Sets the connection state to 'reconnecting' and if the state changed sends the according event.
     */
    reconnecting(): void;
    /**
     * Sets the connection state to 'bufferFull' and if the state changed sends the according event.
     */
    bufferFull(): void;
    /**
     * Sets the connection state to 'disconnected' and if the state changed sends the according event.
     */
    disconnected(): void;
}
/**
 * No-op implementation of WebSocketStateHandler.
 */
export declare class NoopWebSocketStateHandler implements WebSocketStateHandler {
    backPressure(): void;
    bufferFull(): void;
    buffering(): void;
    connected(): void;
    disconnected(): void;
    reconnecting(): void;
}
export interface WebSocketImplementation {
    /**
     * Sends the request to over the web socket connection.
     *
     * @param request - The request to send.
     * @return a Promise for the reestablished web socket connection.
     */
    executeCommand(request: string): void;
}
export interface WebSocketImplementationBuilderHandler {
    /**
     * Sets the handler to send responses to.
     *
     * @param handler - The handler that gets called for responses from the web socket.
     * @return a Promise for the established web socket connection.
     */
    withHandler(handler: ResponseHandler): Promise<WebSocketImplementation>;
}
export interface ResponseHandler {
    /**
     * Parses and processes an input received through the web socket connection.
     *
     * @param input - The received input.
     */
    handleInput(input: string): void;
    /**
     * Processes a response to a request.
     *
     * @param id - the correlation-id of the received response
     * @param response - The response.
     */
    handleResponse(id: string, response: DittoProtocolResponse): void;
    /**
     * Passes a Message that doesn't belong to a request on.
     *
     * @param message - The message.
     */
    handleMessage(message: DittoProtocolResponse): void;
    /**
     * Initiates the reconnecting process and rejects all ongoing requests.
     *
     * @param promise - The promise for the new reconnected web socket.
     */
    handleClose(promise: Promise<WebSocketImplementation>): void;
    /**
     * Deletes a failed request and passes it on as failed.
     *
     * @param id - The id of the failed request.
     * @param reason - The reason the request failed.
     */
    handleFailure(id: string, reason: any): void;
    /**
     * Handles an error received by the web socket connection.
     *
     * @param error - The error.
     */
    handleError(error: string): void;
}
export interface PromiseResponse {
    resolve: (response?: any) => void;
    reject: (reason: any) => void;
}
export interface MessageInformation {
    resolve: ((response?: any) => void)[];
    reject: ((reason: any) => void)[];
}
export declare const connectionUnavailableError: {
    status: number;
    error: string;
    message: string;
    description: string;
};
export declare const connectionInterruptedError: {
    status: number;
    error: string;
    message: string;
    description: string;
};
export declare const connectionLostError: {
    status: number;
    error: string;
    message: string;
    description: string;
};
export declare const bufferFullError: {
    status: number;
    error: string;
    message: string;
    description: string;
};
/**
 * A handler to keep track of the state of a connection and to communicate changes to it.
 */
export declare class ResilienceStateHandler implements WebSocketStateHandler {
    private state;
    private readonly stateHandler;
    constructor(state: ConnectionState, stateHandler: WebSocketStateHandler);
    /**
     * Checks whether a buffer is used.
     *
     * @returns Whether a buffer is used
     */
    isBuffering(): boolean;
    /**
     * Checks whether the connection is still working or completely disconnected.
     *
     * @returns Whether the connection is still working
     */
    isWorking(): boolean;
    /**
     * Checks whether the connection is able to send requests.
     *
     * @returns Whether the connection is able to send requests
     */
    canSend(): boolean;
    /**
     * Checks whether the connection is connected and not using a buffer.
     *
     * @returns Whether the connection is connected and not using a buffer
     */
    isConnected(): boolean;
    connected(): void;
    buffering(): void;
    backPressure(): void;
    reconnecting(): void;
    bufferFull(): void;
    disconnected(): void;
}
/**
 * An enum containing the different states a connection can be in.
 */
export declare enum ConnectionState {
    Connected = 0,
    Buffering = 1,
    BackPressure = 2,
    Reconnecting = 3,
    Connecting = 3,
    BufferFull = 4,
    Disconnected = 5
}
//# sourceMappingURL=websocket-resilience-interfaces.d.ts.map