"use strict";
/*!
 * Copyright (c) 2019 Contributors to the Eclipse Foundation
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0
 *
 * SPDX-License-Identifier: EPL-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Exists = exports.Like = exports.In = exports.Le = exports.Lt = exports.Ge = exports.Gt = exports.Ne = exports.Eq = exports.Not = exports.Or = exports.And = void 0;
class DefaultFilter {
    constructor(_value) {
        this._value = _value;
    }
    /**
     * Returns the filter string.
     *
     * @return the filter in string form.
     */
    toString() {
        return this._value;
    }
}
/**
 * Combines Filters to an and-Filter. All Filters provided must be fulfilled.
 *
 * @param filter - The filters to combine.
 * @return The and-Filter.
 */
exports.And = (...filter) => {
    return new DefaultFilter(`and(${toList(filter)})`);
};
/**
 * Combines Filters to an or-Filter. At least one Filter provided must be fulfilled.
 *
 * @param filter - The filters to combine.
 * @return The or-Filter.
 */
exports.Or = (...filter) => {
    return new DefaultFilter(`or(${toList(filter)})`);
};
/**
 * Negates a Filter to a not-Filter.
 *
 * @param query - The filter to negate.
 * @return The not-Filter.
 */
exports.Not = (query) => {
    return new DefaultFilter(`not(${query.toString()})`);
};
/**
 * Builds an eq-Filter. The body of the property must equal the body
 *
 * @param property - The property to check.
 * @param value - The body to check for.
 * @return The eq-Filter.
 */
exports.Eq = (property, value) => {
    return standardFilter('eq', property, value);
};
/**
 * Builds a ne-Filter. The body of the property must not equal the body
 *
 * @param property - The property to check.
 * @param value - The body to check for.
 * @return The ne-Filter.
 */
exports.Ne = (property, value) => {
    return standardFilter('ne', property, value);
};
/**
 * Builds a gt-Filter. The body of the property must be greater than the body
 *
 * @param property - The property to check.
 * @param value - The body to check for.
 * @return The gt-Filter.
 */
exports.Gt = (property, value) => {
    return standardFilter('gt', property, value);
};
/**
 * Builds a ge-Filter. The body of the property must be greater than or equal to the body
 *
 * @param property - The property to check.
 * @param value - The body to check for.
 * @return The ge-Filter.
 */
exports.Ge = (property, value) => {
    return standardFilter('ge', property, value);
};
/**
 * Builds a lt-Filter. The body of the property must be less than the body
 *
 * @param property - The property to check.
 * @param value - The body to check for.
 * @return The lt-Filter.
 */
exports.Lt = (property, value) => {
    return standardFilter('lt', property, value);
};
/**
 * Builds a le-Filter. The body of the property must be less than or equal to the body
 *
 * @param property - The property to check.
 * @param value - The body to check for.
 * @return The le-Filter.
 */
exports.Le = (property, value) => {
    return standardFilter('le', property, value);
};
/**
 * Builds an in-Filter. The body of the property must be among the values
 *
 * @param property - The property to check.
 * @param value - The values to check for.
 * @return The in-Filter.
 */
exports.In = (property, ...value) => {
    return new DefaultFilter(`in(${property},${value.map(stringify).join()})`);
};
/**
 * Builds a like-Filter. The body of the property must conform to the form provided.
 *
 * @param property - The property to check.
 * @param form - The values to check for.
 * @return The like-Filter.
 */
exports.Like = (property, form) => {
    return standardFilter('like', property, form);
};
/**
 * Builds a exists-Filter. The property must exist.
 *
 * @param property - The property to check.
 * @return The exists-Filter.
 */
exports.Exists = (property) => {
    return new DefaultFilter(`exists(${property})`);
};
/**
 * Combines Filters to one string.
 *
 * @param filter - The filters to combine.
 * @return The combined Filter.
 */
const toList = (filter) => {
    return filter.map(f => f.toString()).join();
};
/**
 * Returns a string representation that can be used as a filter value:
 * number & boolean -> string representation
 * object -> JSON string
 * string -> string in quotes
 *
 * @param value The value of arbitrary type to stringify
 */
const stringify = (value => {
    if (typeof value === 'boolean' || typeof value === 'number') {
        return value.toString();
    }
    if (typeof value === 'object') {
        return JSON.stringify(value);
    }
    return `"${value}"`;
});
/**
 * Standard operation for building Filters.
 *
 * @param operation - The type of Filter to build.
 * @param property - The property to check.
 * @param value - The body to check for.
 * @return The Filter.
 */
const standardFilter = (operation, property, value) => {
    return new DefaultFilter(`${operation}(${property},${stringify(value)})`);
};
//# sourceMappingURL=filter.options.js.map