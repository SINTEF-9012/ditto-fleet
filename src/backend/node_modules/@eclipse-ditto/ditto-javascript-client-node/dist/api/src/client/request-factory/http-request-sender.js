"use strict";
/*!
 * Copyright (c) 2019 Contributors to the Eclipse Foundation
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0
 *
 * SPDX-License-Identifier: EPL-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpRequestSenderBuilder = exports.HttpRequestSender = void 0;
const request_sender_1 = require("./request-sender");
const auth_provider_1 = require("../../auth/auth-provider");
/**
 * Handle to send HTTP requests.
 */
class HttpRequestSender extends request_sender_1.RequestSender {
    constructor(requester, baseUrl, authenticationProviders) {
        super();
        this.requester = requester;
        this.baseUrl = baseUrl;
        this.authenticationProviders = authenticationProviders;
    }
    fetchRequest(options) {
        return this.requester.doRequest(options.verb, this.buildUrl(options.id, options.path, options.requestOptions), this.buildHeader(options.requestOptions), JSON.stringify(options.payload))
            .then(response => {
            if (response.status >= 200 && response.status < 300) {
                return response;
            }
            return Promise.reject(response.body);
        });
    }
    /**
     * Builds a URL to make HTTP calls with.
     *
     * @param id - The id of the basic entity the request is for.
     * @param path - The path to the entity the request is about from the basic entity.
     * @param options - The options provided in the request.
     * @returns The request URL
     */
    buildUrl(id, path, options) {
        let urlSuffix = id === undefined ? '' : `/${id}`;
        urlSuffix = path === undefined ? urlSuffix : `${urlSuffix}/${path}`;
        if (options !== undefined && options.getOptions().size > 0) {
            const values = options.getOptions();
            let result = '';
            values.forEach((v, k) => {
                result += `&${k}=${v}`;
            });
            urlSuffix = `${urlSuffix}?${result.substr(1)}`;
        }
        const baseUrlWithSuffix = this.baseUrl.withPath(`${this.baseUrl.path}${urlSuffix}`);
        const authenticatedBaseUrl = auth_provider_1.authenticateWithUrl(baseUrlWithSuffix, this.authenticationProviders);
        return authenticatedBaseUrl.toString();
    }
    /**
     * Builds headers to make HTTP calls with by combining authentication and options headers.
     * Options headers will override authentication headers.
     *
     * @param options - The options to provided in the request.
     * @returns The combined headers
     */
    buildHeader(options) {
        const headers = new Map();
        if (options) {
            options.getHeaders().forEach((v, k) => headers.set(k, v));
        }
        if (!headers.has('Content-Type')) {
            headers.set('Content-Type', 'application/json');
        }
        let authenticatedHeaders = headers;
        for (const authenticationProvider of this.authenticationProviders) {
            authenticatedHeaders = authenticationProvider.authenticateWithHeaders(authenticatedHeaders);
        }
        return authenticatedHeaders;
    }
}
exports.HttpRequestSender = HttpRequestSender;
/**
 * A Factory for a HttpRequestSender.
 */
class HttpRequestSenderBuilder {
    constructor(requester, url, authProviders) {
        this.requester = requester;
        this.url = url;
        this.authProviders = authProviders;
    }
    buildInstance(group) {
        return new HttpRequestSender(this.requester, this.url.withPath(`${this.url.path}/${group}`), this.authProviders);
    }
}
exports.HttpRequestSenderBuilder = HttpRequestSenderBuilder;
//# sourceMappingURL=http-request-sender.js.map