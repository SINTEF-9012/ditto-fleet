/*!
 * Copyright (c) 2019 Contributors to the Eclipse Foundation
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0
 *
 * SPDX-License-Identifier: EPL-2.0
 */
import { AbstractResilienceHandler, RequestHandler, ResilienceHandler, ResilienceHandlerFactory, ResilienceHandlerFactoryContextStep, WebSocketImplementation, WebSocketImplementationBuilderHandler, WebSocketStateHandler } from './websocket-resilience-interfaces';
import { DittoProtocolEnvelope, DittoProtocolResponse } from '../../../model/ditto-protocol';
/**
 * An implementation of ResilienceHandler that buffers requests during temporary connection problems and backpressure.
 */
export declare class StandardResilienceHandler extends AbstractResilienceHandler {
    private readonly requestBuffer;
    private readonly messageBuffer;
    private webSocket;
    constructor(webSocketBuilder: WebSocketImplementationBuilderHandler, stateHandler: WebSocketStateHandler, requestHandler: RequestHandler, size: number);
    sendRequest(correlationId: string, request: DittoProtocolEnvelope): void;
    send(message: string): Promise<void>;
    handleResponse(correlationId: string, response: DittoProtocolResponse): void;
    handleFailure(correlationId: string, reason: any): void;
    /**
     * Handles the promise for a new web socket. Once the Promise is resolved it will be set as the web socket for the resilience handler.
     * If the Promise gets rejected the reconnection process will be stopped and all further requests rejected.
     * After the Promise is resolved emptying of the buffer will be initiated. As long as there are requests left in the buffer new
     * requests will continue to be added to the buffer.
     *
     * @param promise - The promise for the new web socket
     */
    protected resolveWebSocket(promise: Promise<WebSocketImplementation>): void;
    /**
     * Adds a request to the buffer. It initiates polling if the buffer was empty before.
     *
     * @param id - The id of the request to buffer
     */
    private addToOutstandingBuffer;
    /**
     * Rejects and deletes all ongoing requests.
     *
     * @param reason - The reason to reject the requests with.
     */
    protected rejectAllOngoing(reason: object): void;
    /**
     * Rejects and deletes a request.
     *
     * @param id - The id of the request to reject.
     * @param reason - The reason to reject the request with.
     */
    private rejectRequest;
    /**
     * Sends the next element of the request buffer and if there was such an element will do the same thing again in 500ms.
     */
    private poll;
    /**
     * Checks whether the buffer is full, used or empty and sets the state accordingly.
     */
    private checkBufferState;
}
/**
 * A Factory for a StandardResilienceHandler.
 */
export declare class StandardResilienceHandlerFactory extends ResilienceHandlerFactory {
    private readonly size;
    private constructor();
    /**
     * Provides an instance of StandardResilienceHandlerFactory.
     *
     * @param size - The maximum size to use for the buffers.
     * @returns The instance of StandardResilienceHandlerFactory
     */
    static getInstance(size: number): ResilienceHandlerFactoryContextStep;
    withRequestHandler(requestHandler: RequestHandler): ResilienceHandler;
}
//# sourceMappingURL=websocket-resilience-handler-standard.d.ts.map