"use strict";
/*!
 * Copyright (c) 2019 Contributors to the Eclipse Foundation
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0
 *
 * SPDX-License-Identifier: EPL-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BufferlessResilienceHandlerFactory = exports.BufferlessResilienceHandler = void 0;
const websocket_resilience_interfaces_1 = require("./websocket-resilience-interfaces");
/**
 * An implementation of ResilienceHandler without buffering.
 */
class BufferlessResilienceHandler extends websocket_resilience_interfaces_1.AbstractResilienceHandler {
    constructor(webSocketBuilder, stateHandler, requestHandler) {
        super(stateHandler, requestHandler);
        this.requests = new Map();
        this.resolveWebSocket(webSocketBuilder.withHandler(this));
    }
    sendRequest(id, request) {
        if (this.stateHandler.isConnected()) {
            const jsonified = request.toJson();
            this.requests.set(id, jsonified);
            this.webSocket.executeCommand(jsonified);
        }
        else {
            this.handleFailure(id, this.connectionProblemRejectionReason());
        }
    }
    send(message) {
        if (this.stateHandler.isConnected()) {
            this.webSocket.executeCommand(message);
            return Promise.resolve();
        }
        return Promise.reject(this.connectionProblemRejectionReason());
    }
    handleResponse(correlationId, response) {
        this.requests.delete(correlationId);
        this.requestHandler.handleInput(correlationId, response);
    }
    handleFailure(id, reason) {
        this.requests.delete(id);
        this.requestHandler.handleError(id, reason);
    }
    /**
     * Returns the reason to reject a Promise based on the current state of the connection.
     *
     * @returns The error to reject with
     */
    connectionProblemRejectionReason() {
        return this.stateHandler.isWorking() ? websocket_resilience_interfaces_1.connectionUnavailableError : websocket_resilience_interfaces_1.connectionLostError;
    }
    /**
     * Handles the promise for a new web socket. Once the Promise is resolved it will be set as the web socket for the resilience handler.
     * If the Promise gets rejected the reconnection process will be stopped and all further requests rejected.
     *
     * @param promise - The promise for the new web socket
     */
    resolveWebSocket(promise) {
        promise
            .then(socket => {
            this.webSocket = socket;
            this.stateHandler.connected();
        }, error => {
            this.stateHandler.disconnected();
            this.rejectAllOngoing(websocket_resilience_interfaces_1.connectionLostError);
            throw error;
        });
    }
    /**
     * Rejects all ongoing requests.
     *
     * @param reason - The reason to reject the requests with
     */
    rejectAllOngoing(reason) {
        const ongoingRequests = new Map(this.requests);
        ongoingRequests.forEach((_, id) => this.handleFailure(id, reason));
    }
}
exports.BufferlessResilienceHandler = BufferlessResilienceHandler;
/**
 * A Factory for a BufferlessResilienceHandler.
 */
class BufferlessResilienceHandlerFactory extends websocket_resilience_interfaces_1.ResilienceHandlerFactory {
    constructor() {
        super();
    }
    /**
     * Provides an instance of BufferlessResilienceHandlerFactory.
     *
     * @returns The instance of BufferlessResilienceHandlerFactory
     */
    static getInstance() {
        return new BufferlessResilienceHandlerFactory();
    }
    withRequestHandler(requestHandler) {
        return new BufferlessResilienceHandler(this.webSocketBuilder, this.stateHandler, requestHandler);
    }
}
exports.BufferlessResilienceHandlerFactory = BufferlessResilienceHandlerFactory;
//# sourceMappingURL=websocket-resilience-handler-bufferless.js.map