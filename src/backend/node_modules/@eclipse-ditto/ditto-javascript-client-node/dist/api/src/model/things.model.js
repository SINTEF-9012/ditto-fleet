"use strict";
/*!
 * Copyright (c) 2019 Contributors to the Eclipse Foundation
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0
 *
 * SPDX-License-Identifier: EPL-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Feature = exports.Metadata = exports.Features = exports.Thing = void 0;
const model_1 = require("./model");
/**
 * Representation of a Thing
 */
class Thing extends model_1.EntityWithId {
    constructor(_thingId, _policyId, _attributes, _features, __revision, __modified, _definition, __metadata, __created) {
        super();
        this._thingId = _thingId;
        this._policyId = _policyId;
        this._attributes = _attributes;
        this._features = _features;
        this.__revision = __revision;
        this.__modified = __modified;
        this._definition = _definition;
        this.__metadata = __metadata;
        this.__created = __created;
    }
    /**
     * Parses a Thing.
     *
     * @param o - The object to parse.
     * @returns The Thing
     */
    static fromObject(o) {
        if (o === undefined) {
            return o;
        }
        // @ts-ignore
        return new Thing(o['thingId'], o['policyId'], o['attributes'], Features.fromObject(o['features']), o['_revision'], o['_modified'], o['definition'], Metadata.fromObject(o['_metadata']), o['_created']);
    }
    static empty() {
        return new Thing('', '', undefined, undefined, 0, '', undefined, undefined, undefined);
    }
    toObject() {
        const featuresObj = Features.toObject(this.features);
        return model_1.EntityModel.buildObject(new Map([
            ['thingId', this.thingId],
            ['policyId', this.policyId],
            ['attributes', this.attributes],
            ['features', featuresObj],
            ['_revision', this._revision],
            ['_modified', this._modified],
            ['definition', this._definition],
            ['_created', this.__created]
        ]));
    }
    get thingId() {
        return this._thingId;
    }
    get id() {
        return this._thingId;
    }
    get policyId() {
        return this._policyId;
    }
    get attributes() {
        return this._attributes;
    }
    get features() {
        return this._features;
    }
    get _modified() {
        return this.__modified;
    }
    get _revision() {
        return this.__revision;
    }
    get _metadata() {
        return this.__metadata;
    }
    get namespace() {
        return this.separateNamespaceAndThingId().namespace;
    }
    get name() {
        return this.separateNamespaceAndThingId().name;
    }
    get definition() {
        return this._definition;
    }
    get _created() {
        return this.__created;
    }
    separateNamespaceAndThingId() {
        const indexOfFirstColon = this.thingId.indexOf(':');
        if (indexOfFirstColon >= 0) {
            const namespace = this.thingId.substring(0, indexOfFirstColon);
            const name = this.thingId.length === indexOfFirstColon ? '' : this.thingId.substring(indexOfFirstColon + 1);
            return { namespace, name };
        }
        return { namespace: '', name: this.thingId };
    }
}
exports.Thing = Thing;
Thing.NAMESPACE_SEPARATION_REGEX = /([^:]*):(.*)/;
/**
 * Representation of Features
 */
class Features extends model_1.IndexedEntityModel {
    /**
     * Parses Features.
     *
     * @param o - The object to parse.
     * @returns The Features
     */
    static fromObject(o) {
        if (o === undefined) {
            return o;
        }
        return model_1.IndexedEntityModel.fromPlainObject(o, Feature.fromObject);
    }
}
exports.Features = Features;
class Metadata extends model_1.EntityModel {
    constructor(_attributes, _features) {
        super();
        this._attributes = _attributes;
        this._features = _features;
    }
    get attributes() {
        return this._attributes;
    }
    get features() {
        return this._features;
    }
    static fromObject(o) {
        if (o === undefined) {
            return o;
        }
        return new Metadata(o.attributes, Features.fromObject(o.features));
    }
    toObject() {
        const features = this.features ? Features.toObject(this.features) : undefined;
        return model_1.EntityModel.buildObject(new Map([
            ['features', features],
            ['attributes', this.attributes]
        ]));
    }
}
exports.Metadata = Metadata;
/**
 * Representation of a Feature
 */
class Feature extends model_1.EntityWithId {
    constructor(_id, _definition, _properties) {
        super();
        this._id = _id;
        this._definition = _definition;
        this._properties = _properties;
    }
    /**
     * Parses a Feature.
     *
     * @param o - The object to parse.
     * @param key - The key of the new Feature.
     * @returns The Feature
     */
    static fromObject(o, key) {
        if (o === undefined) {
            return o;
        }
        // @ts-ignore
        return new Feature(key, o['definition'], o['properties']);
    }
    toObject() {
        return model_1.EntityModel.buildObject(new Map([
            ['definition', this.definition],
            ['properties', this.properties]
        ]));
    }
    get id() {
        return this._id;
    }
    get definition() {
        return this._definition;
    }
    get properties() {
        return this._properties;
    }
}
exports.Feature = Feature;
//# sourceMappingURL=things.model.js.map