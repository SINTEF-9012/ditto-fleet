"use strict";
/*!
 * Copyright (c) 2019 Contributors to the Eclipse Foundation
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0
 *
 * SPDX-License-Identifier: EPL-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProxyAgent = void 0;
const { UrlWithStringQuery, parse } = require('url');
const HttpsProxyAgent = require('https-proxy-agent');
const HttpProxyAgent = require('http-proxy-agent');
class ProxyAgentOptionsBuilder {
    constructor() {
        this.proxyUrl = {};
        this.proxyCredentials = {};
        /* intentionally empty */
    }
    static newInstance(options, environmentProxy) {
        return new ProxyAgentOptionsBuilder()
            .parseUrlFromEnvironment(environmentProxy, options)
            .parseUrlFromOptions(options)
            .parseCredentialsFromOptions(options);
    }
    parseUrlFromOptions(options) {
        if (options !== undefined && options.url !== undefined) {
            this.proxyUrl = parse(options.url);
        }
        return this;
    }
    parseUrlFromEnvironment(environmentProxy, options) {
        // tslint:disable-next-line:strict-boolean-expressions
        const shouldIgnoreProxyFromEnv = options !== undefined && options.ignoreProxyFromEnv;
        // tslint:disable-next-line:strict-boolean-expressions
        if (environmentProxy !== undefined && !shouldIgnoreProxyFromEnv) {
            this.proxyUrl = parse(environmentProxy);
        }
        return this;
    }
    parseCredentialsFromOptions(options) {
        if (options !== undefined && options.username !== undefined && options.password !== undefined) {
            const credentials = `${options.username}:${options.password}`;
            this.proxyCredentials = { headers: { 'Proxy-Authorization': `Basic ${Buffer.from(credentials).toString('base64')}` } };
        }
        return this;
    }
    isEmpty() {
        // can ignore proxyCredentials here, as we can't send credentials if we don't know a proxy location
        return 0 === Object.keys(this.proxyUrl).length;
    }
    getOptions() {
        return Object.assign(Object.assign({}, this.proxyUrl), this.proxyCredentials);
    }
}
function buildHttpsProxyAgent(options) {
    /* tslint:disable-next-line:strict-boolean-expressions */
    const environmentProxy = process.env.https_proxy || process.env.HTTPS_PROXY;
    const proxyOptions = ProxyAgentOptionsBuilder.newInstance(options, environmentProxy);
    return proxyOptions.isEmpty() ? undefined : new HttpsProxyAgent(proxyOptions.getOptions());
}
function buildHttpProxyAgent(options) {
    /* tslint:disable-next-line:strict-boolean-expressions */
    const environmentProxy = process.env.http_proxy || process.env.HTTP_PROXY;
    const proxyOptions = ProxyAgentOptionsBuilder.newInstance(options, environmentProxy);
    return proxyOptions.isEmpty() ? undefined : new HttpProxyAgent(proxyOptions.getOptions());
}
/**
 * Provider of an Agent that establishes a proxy connection.
 */
class ProxyAgent {
    constructor(options) {
        this.httpProxyAgent = buildHttpProxyAgent(options);
        this.proxyAgent = buildHttpsProxyAgent(options);
    }
}
exports.ProxyAgent = ProxyAgent;
//# sourceMappingURL=proxy-settings.js.map