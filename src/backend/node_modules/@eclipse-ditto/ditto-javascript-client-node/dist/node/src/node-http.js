"use strict";
/*!
 * Copyright (c) 2019 Contributors to the Eclipse Foundation
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0
 *
 * SPDX-License-Identifier: EPL-2.0
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeRequester = void 0;
const http = require("http");
const https = require("https");
const response_1 = require("../../api/src/model/response");
/**
 * NodeJs implementation of a Http Requester.
 */
class NodeRequester {
    constructor(agent) {
        this.agent = agent;
    }
    static createResponseHandler(resolve, reject) {
        return response => {
            this.handleResponse(resolve, reject, response);
        };
    }
    static handleResponse(resolve, reject, response) {
        let data = '';
        response.on('data', chunk => {
            data += chunk;
        });
        response.on('end', () => {
            let body;
            if (data === '') {
                body = {};
            }
            else {
                try {
                    body = JSON.parse(data);
                }
                catch (e) {
                    body = data;
                }
            }
            const headersObj = response.headers;
            const headers = Object.keys(headersObj).reduce((map, name) => {
                map.set(name, headersObj[name]);
                return map;
            }, new Map());
            const status = response.statusCode !== undefined ? response.statusCode : 0;
            if (status < 200 || status >= 300) {
                reject(new response_1.BasicErrorResponse(body, status, headers));
            }
            resolve({ status, headers, body });
        });
    }
    doRequest(method, url, header, payload) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise(((resolve, reject) => {
                const parsedUrl = new URL(url);
                const isSecureRequest = parsedUrl.protocol === 'https:';
                const client = isSecureRequest ? https : http;
                const requestOptions = this.buildRequest(method, parsedUrl, header, payload, isSecureRequest);
                const req = client.request(requestOptions, NodeRequester.createResponseHandler(resolve, reject));
                req.on('error', e => {
                    throw new Error(String(e));
                });
                if (payload !== undefined) {
                    req.write(payload);
                }
                req.end();
            }));
        });
    }
    /**
     * Builds an options object to perform a Http request with.
     *
     * @param method - The type of action to perform.
     * @param parsedUrl - The Url to send the request to.
     * @param header - The headers of the request.
     * @param body - The payload to send with the request.
     * @param isSecureRequest - If the request is a secure HTTPS request.
     * @return the builder.
     */
    buildRequest(method, parsedUrl, header, body, isSecureRequest) {
        if (body !== undefined && body !== '') {
            header.set('Content-Length', Buffer.byteLength(body).toString());
        }
        const pathWithQueryParams = `${parsedUrl.pathname}${parsedUrl.search}`;
        const headers = {};
        header.forEach((v, k) => headers[k] = v);
        return {
            method,
            headers,
            hostname: parsedUrl.hostname,
            port: parsedUrl.port,
            path: pathWithQueryParams,
            agent: this.getAgentForRequestType(isSecureRequest)
        };
    }
    getAgentForRequestType(isSecureRequest) {
        return isSecureRequest ? this.agent.proxyAgent : this.agent.httpProxyAgent;
    }
}
exports.NodeRequester = NodeRequester;
//# sourceMappingURL=node-http.js.map